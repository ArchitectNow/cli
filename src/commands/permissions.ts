import { outputFile } from 'fs-extra';
import inquirer from 'inquirer';
import nodeFetch from 'node-fetch';
import ora, { Ora } from 'ora';
import { inject, singleton } from 'tsyringe';
import { CommandsMap } from '../ioc';
import { CommandMap, PermissionsCommandOption } from '../models';
import { Logger } from '../utils';
import { Command } from './command';

@singleton()
export class Permissions extends Command<PermissionsCommandOption> {
  private optionsLoader: Ora = ora();
  private fetchLoader: Ora = ora();
  private generateLoader: Ora = ora();

  constructor(
    @inject(Logger) readonly _logger: Logger,
    @inject(CommandsMap) readonly _commandsMap: CommandMap,
  ) {
    super(_logger, _commandsMap, 'permissions');
  }

  async run(args: string[]) {
    this.logger.info(this.command.description);
    if (!args.length) {
      this.optionsLoader.start('Fetching existing options...');
      const existOptions = await this.getExistOptions();
      if (existOptions) {
        this.optionsLoader.succeed(
          'Found existing options. Executing with the following:',
        );
        this.logger.log(JSON.stringify(existOptions, null, 2));
        await this.fetchAndGenerate(existOptions);
        return 0;
      } else {
        this.optionsLoader.info('Existing options not found. Setting up...');
        const options: PermissionsCommandOption = await inquirer.prompt(
          this.command.options.map(opt => ({
            type: opt.type,
            name: opt.name,
            message: opt.message,
            default: opt.default,
            validate: function (val: any) {
              if (!opt.required) {
                return true;
              }

              return !!val ? true : opt.validationMessage || false;
            },
          })),
        );

        this.optionsLoader.start('Storing options...');
        await this.storeOptions(options);
        this.optionsLoader.succeed('Stored options');
        await this.fetchAndGenerate(options);
        return 0;
      }
    } else {
      const [subCommand] = args;

      switch (subCommand) {
        case 'h':
        case 'help':
          await this.printHelp();
          break;
      }
    }

    return 0;
  }

  private async fetchAndGenerate(options: PermissionsCommandOption) {
    const { url, outputPath, outputName } = options;
    this.fetchLoader.start('Fetching from ' + url);
    const response = await nodeFetch(url).then(res => res.json());
    this.fetchLoader.succeed('Fetched');
    this.generateLoader.start('Generating...');
    await this.generatePermissionsEnum(response, outputPath, outputName);
    this.generateLoader.succeed('Generated');
  }

  private async generatePermissionsEnum(
    response: { [key: string]: any },
    outputPath: string,
    outputName: string,
  ) {
    try {
      const enumValues: string[] = [];
      const convert = (
        permissionsMap: { [key: string]: any },
        prefix?: string,
      ) => {
        for (const [key, val] of Object.entries(permissionsMap)) {
          if (typeof val === 'string') {
            enumValues.push(`${prefix ? prefix.concat(key) : key} = "${val}"`);
          } else {
            convert(val, key);
          }
        }
      };
      convert(response);

      let enumContent = `
// THIS FILE IS AUTO-GENERATED BY @architectnow/cli
// ANY CHANGES MADE TO THIS FILE WILL BE LOST

export enum PermissionNames {
  ${enumValues.sort().join(',\n  ')}
}
      `;

      await outputFile(outputPath + '/' + outputName, enumContent, {
        encoding: 'utf8',
      });
    } catch (e) {
      this.logger.error(e);
      throw e;
    }
  }
}
